var RequestBodyModes = require('postman-collection').RequestBody.MODES,
    ItemGroup = require('postman-collection').ItemGroup,
    Item = require('postman-collection').Item,
    LuaHelper = require('../lua-helper'),
    util = require('util');

var LuaGenerator = {

  convert: function(postmanCollection) {

    if (!postmanCollection || postmanCollection.items.count() === 0 ) {
      return '-- No HTTP/HTTPS transactions have been recorded.';
    }

    var result = [],
        folderRequests,
        requests = [],
        allVariables = [],
        luaRequest;

    result.push(util.format("--Auto-generated by the Load Impact converter"));
    result.push("");
    result.push(util.format("local sleep_time = 10"));
    result.push(util.format("local response"));

    postmanCollection.items.each(function(item) {

      if (ItemGroup.isItemGroup(item)) {

        var folder = item;
        if (folder.auth) { throw new Error(' TODO: folder.auth'); }

        result.push(util.format('-- %s\n', folder.name));

        folder.items.each(function(folderItem) {

          luaRequest = convertToLuaRequest(folderItem);
          allVariables = allVariables.concat(luaRequest.variables);
          result.push(luaRequest.result);

        });

      } else if (Item.isItem(item)) {

        luaRequest = convertToLuaRequest(item);
        allVariables = allVariables.concat(luaRequest.variables);
        result.push(luaRequest.result);

      } else {

        throw new Error(' TODO: Implement postCollection item');

      }

    });

    if (allVariables.length) {

      allVariables = arrayUnique(allVariables);

      result.splice(4, 0, "");
      for (var j = allVariables.length - 1; j >= 0; j--) {

        result.splice(4, 0, util.format("local %s = \"YOUR_VALUE\"", allVariables[j]));

      }
      result.splice(4, 0, "");

    }

    return result.join('\n');

  }

};
function arrayUnique(array) {
    var a = array.concat();
    for(var i=0; i<a.length; ++i) {
        for(var j=i+1; j<a.length; ++j) {
            if(a[i] === a[j])
                a.splice(j--, 1);
        }
    }

    return a;
}


function convertToLuaRequest(item) {

  var request = item.request,
      body = request.body,
      method,
      url,
      data,
      postRequest,
      preRequest,
      auth = request.auth,
      headerHash = {},
      authHeader,
      headers = [];


  // read method & url
  method = request.method;
  url = request.url.toString();


  // read test and preRequest functions
  if (item.events.count() > 0) {

    item.events.each(function(event) {
      var script;
      if (event.listen === 'test') {
        script = event.script.exec;
        if (script.length) {
          //Lua commented
          postRequest = util.format("--[[\n%s\n--]]\n", script.join('\n'));
        }
      } else if (event.listen === 'prerequest') {
        script = event.script.exec;
        if (script.length) {
          //Lua commented
          preRequest = util.format("--[[\n%s\n--]]\n", script.join('\n'));
        }
      }
    });

  }


  // get headers & auth into headerHash
  request.headers.each(function(header) {
    headerHash[header.key] = header.value;
  });

  // add or overwrite auth header
  if (auth && auth.type) {

    var AuthenticationManager = moduleExist('./auth/' + auth.type);
    if (AuthenticationManager && AuthenticationManager.enabled) {

      authHeader = AuthenticationManager.header(request);

      // convert headerHash to arrayHeaders
      if (authHeader) {
        delete headerHash.Authorization;
        headers.push(authHeader);
      }
    } else {

      var authenticationComment;
      if (auth.type === 'awsv4' || auth.type === 'hawk' || auth.type === 'oauth1') {

        authenticationComment = util.format("Note: %s dynamic authentication is not supported", auth.type);

      } else if (auth.type === 'digest') {

        authenticationComment = util.format("Note: Refer to %s for dynamic digest authentication", "http://support.loadimpact.com/knowledgebase/articles/174596-http-basic-digest-ntlm-authentication");

      }

      if (authenticationComment) {

        postRequest = postRequest || '';
        postRequest += util.format("--[[\n%s\n--]]\n", authenticationComment);

      }


    }
  }


  Object.keys(headerHash).forEach(function(key) {
    var tmpHeader = util.format("[\"%s\"]=\"%s\"", key, LuaHelper.escapeContent(headerHash[key]));
    headers.push(tmpHeader);
  });


  // read body
  var bodyData = body[body.mode];
  if (bodyData) {

    if (body.mode === RequestBodyModes.raw) {
      data = LuaHelper.escapeContent(bodyData);
    } else if (bodyData.count() > 0) {
      //body.mode === RequestBodyModes.formdata
      //body.mode === RequestBodyModes.urlencoded
      //should we add default CONTENT-TYPE Header `application/x-www-form-urlencoded`?

      var params = [];
      bodyData.each(function(paramItem) {
        params.push(util.format('%s=%s', encodeURIComponent(paramItem.key), encodeURIComponent(paramItem.value)));
      });

      data = params.join('&');

    }

  }

  return LuaHelper.buildLuaRequest({
    url: url,
    method: method,
    headers: headers,
    data: data,
    preRequest: preRequest,
    postRequest: postRequest,
    sleepTime: 'sleep_time',
    variable: 'response'
  });

}

function moduleExist(name){
  try { return require(name); }
  catch(e) { return false; }
}


module.exports = LuaGenerator;
